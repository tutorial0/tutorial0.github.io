[{"categories":["Security"],"content":"记得以前看过一个文章，有一句话让我一直忘不掉，他说“黑盒扫描器根本没什么架构，只要POC够多就好了“。 当时我以为只是一家之言，应该不会有什么人赞同，但是没想到这些年不管是线下和人聊天还是线上看人文章，都没什么反对。 所以，今天写这个文章，就是想证明下其实扫描器也是有不同的架构的，并且在一些不同场景下会有不同的最佳架构。\n什么是好的漏扫 低漏报+低误报？ 理想状态下，我们希望我们的黑盒扫描器能尽可能低漏报的发现尽量多的漏洞。但很可惜，低漏报和低误报这俩在很多情况下是矛盾的。 想要做到低漏报，就要尽量多的触发各种可能的FUZZ，但越多的FUZZ越容易触发防护措施，导致误报。即使是在去掉防护措施任君采撷的场景下，一堆参数FUZZ也可能导致程序出BUG、反应慢等等问题，进而触发更多误报。 换个角度来说，从投入上来考虑，如果想让扫描器尽量多的扫出漏洞，就要尽量多的增加POC，但同时为了精准，又要对每个POC预期的返回进行精确的定义。这就把本来就挺复杂的POC编写任务的难度又提高了一点，自然就增加了开发成本。 所以，低漏报还是低误报是我们事先一定要做好的取舍，而不是两者都要，小孩子才说我全都要，大人都知道身体受不了。 从本质上来说，这个取舍是一个基于成本的取舍。即使你家大业大，毫不在意开发过程的时间或资金投入，对扫描时间和扫描成本也毫不在意，你觉得你优势很大，但也请结合安全人员薪资和开发时间以及漏洞出现频率算算账，这个成本并不小，而且是个无底洞。\n只考虑漏报和误报？ 但漏扫只要关注漏报误报吗？也不是，漏扫还有很多用处，比如作为渗透测试的辅助工具。这时候相对于尽可能低漏报的发现尽量多的漏洞这个需求，更希望它能做到尽可能多的触发一些值得注意的信息，给我们在后续的测试中省点力。特别是做一些高难度的渗透的时候，大家会希望有这样的工具，因为这种场景下，很难有直接的漏洞产出，能给到有用的信息就已经很有价值了。在这种场景下，就根本无所谓什么漏报和误报了。\n什么漏扫架构最好？ 上面两段分析已经说明，要看具体情况分析，某些情况下的“好”扫描器，放到其他情况就没什么用。 我按照一般的使用场景分一下，大概有这些：\n那他们适合什么架构呢，先要总结下有哪些架构存在。\n有哪些漏扫架构 探讨完了如何评价一个漏扫，那么我们再回到漏扫架构的问题，因为每种不同的架构是希望解决不同漏扫的问题而产生的。 当然，由于我个人能力限制，这里写的只是我知道的架构，也欢迎各位补充。 由于之前也没有人给他们的架构命名，所以我自己随便起名，希望尽量做到能概括架构特点。\n信息网状架构 记得最初发现这种漏扫架构是因为逆向了BugScan，初见时的震惊我到现在都还记得，它的架构颠覆了我对漏扫的印象，所以我把这类架构放到第一个来说。顺带一说，对这位写出BugScan的前辈我还是挺佩服的，不过由于这位大佬目前似乎退出安全圈子研究别的领域，所以就不提他的名字，不打扰人家了。 故事说完，来说框架，当时我逆向了这个扫描器，发现它的结构和常见的扫描器的确不同，体现在这几点设计上：\n 一切都是插件 一切插件都是平等的 信息为所有插件共享 信息是可以多次处理的 上面这些听起来不容易理解，我就直接说一下这样设计的好处：    核心功能改动简单，对整体影响非常小\n即使是爬虫、被动扫描、CMS识别这样的功能，也只是插件而已，对其他插件来说是透明的\n  能更多的发现漏洞或信息\n在其他架构里，信息只会按顺序处理一次就结束了，但渗透过程并不是那么理想的，在”信息收集“阶段就能收集完所有信息，然后进入”测试“阶段去利用所有信息。而由于插件间可以互相调用，信息又是共享的，所以在整个扫描阶段，扫描器其实都是在做信息收集和处理的。这和我们人工来做渗透测试的相似度更高，效果也更好\n  插件独立，开发难度降低\n似乎所有支持插件的架构，插件都比较独立，但是在这种架构下，插件的独立程度可以更高，因为插件之间是可以动态交互来互相调用功能的，这就省掉了很多开发的逻辑。举个例子，在这种框架里开发一个爬虫该怎么做？很简单，只需要访问单个URL并解析链接，然后对新发现的链接，推送新的任务即可\n  天然支持分布式\n这种设计下，插件和调度核心非常容易拆开，所以很容易做成分布式的样子\n  更容易结合人工做到半自动化扫描\n其他的设计下，人工是无法干预的，扫描器跑起来就和人无关了，跑起来之前，你也只能设置一些简单的选项，顶多有一些认证信息设置之类。但是对于这种扫描器，你几乎可以把自己已知的各种信息配置起来。比如你已经知道系统使用了某个CMS，那么就可以在初始触发的信息处增加这个信息，扫描器就会认为有插件识别出了CMS，并直接进行后续利用\n  这样的框架在尽量多的信息收集时，非常有用。不过也更容易触发防护，因为它对于信息的利用率是非常高的。\n线性架构 这是最常见的两种架构之一，比如PocSuite这样的漏扫，有的人甚至认为它不应该叫漏扫，因为它就只是把一堆POC打出去。 这里的设计就很简单：\n 不考虑是否可能被拦截，尽量发现最严重的问题 不需要提供更多后续信息，没有结果就算了  这样的架构一般适合做高危漏洞巡航，比如全公司、全网扫某漏洞。所以一般这样的框架还会做好并发功能或分布式扫描功能。 当然，这样的写法，最大的优点是，开发简单同时提供了一个规范的POC结构，对于组织进行POC收集最好不过。\n瀑布式架构 这是最经典的扫描架构，AWVS就是这种架构的扫描器。 它的设计包括：\n 分阶段，按照标准的信息收集、FUZZ之类流程进行 插件是二等公民，模块位于插件之上 谁生产的信息谁消费掉，只会用一次 插件之间无法通信 这样的设计也有一些好处，即它能尽量少的干扰目标，尽量少的触发WAF等防护。 那么代价是什么呢？代价就是对一些信息的遗漏，也就是一些漏报。  多层瀑布架构 这是对于经典扫描架构的一些改良，最初见到似乎是猪猪侠给出的那个分布式扫描器(Python+Celery)。不过我也只是有个大概印象，可能不是这个扫描器，时间长了有些记不清了。 它的主要设计包括：\n 和瀑布架构一样分阶段进行测试 每个阶段支持信息共享 同阶段插件平等 这样的设计，看起来采取了瀑布式架构的优点和网状架构的优点，但是并没能完整利用到网状架构能不停进行信息搜集的好处，其实和瀑布架构差不多，不过更方便进行分布式扫描，对于一些特殊的场景会有一些用处。比如某些目标机器在内网，或者有大量目标要扫描。  选择最适合的架构 综上，最适合的架构才是最好的，虽说我上面已经基本给出了每种架构适合的场景，但还是不太直观，所以我写了个简单的表格，尽量覆盖常见的黑盒扫描器使用场景。 不过，这个表包含了我自己对每个场景的需求的判断，如果你对场景的基础假设，特别是漏报和误报的容忍度与我不同，那你的结论可能和我不一样，所以，此表仅供参考。\n总结 可能在一些人看来我上面写的不太详细，毕竟没有给出一些模块图之类的介绍，只是简单介绍了主要设计思路和效果。但是毕竟我的目的就是想要证明下的确存在不同的扫描器架构，并且他们适合不同场景，我觉得这样就足够了。\n","date":"2021-09-26","permalink":"/zh-cn/posts/positive-secscanner-arch/","series":null,"tags":["编程","网络安全","主动扫描器","安全开发"],"title":"主动扫描器没有架构一说吗?"},{"categories":["Coding"],"content":"对于一个非专业开发而言，提升开发能力是一个很困难的事，我在这方面走了很多弯路，近期感觉略有所得，所以写个文章分享下感受。\n我的编程能力提升之路 文章名既然叫代码阅读思路，自然是因为我认为在无人指导的情况下，代码阅读是提升开发能力的最好办法。为啥这么说，因为我基本踩过了其他各种方法的坑。这一节回顾下那些坑爹日子，没兴趣的跳过好了，不影响后续阅读。\n大学时代 在大学时代，没有项目经验，在我看来编程就是“算法+无营养的业务”，于是这时候我的思路就是去学算法，我加入了ACM社团，到毕业后甚至还有一个ACM金奖。\n刚刚工作 然后我就发现尴尬了，原来工作里需要的一些工具我还是开发不来，原来跑得快不是最重要的需求。这时候我脑海里单一的编程项目变成了两种情景，一是底层开发，二是应用开发。这时候开始逐渐理解设计模式到底是干什么的，明白了算法在实际产品开发过程中几乎没啥意义。但是只是明白也没用，项目需求稍微复杂一点我就没法实现了，或者写成麻花一样，顶多就是玩具。\n在这一段时间比较迷茫，不知道该怎么学习，偶然间也认识了一些“开发大佬”，他们对语言/库的API非常熟悉，写个一天一点不用查资料，代码好看整洁，目录分配合理，容易分工和二次修改。\n于是开始了解到“重构”、“整洁代码”等思想和一些相关的书，代码自然也变整洁了，看起来似乎像回事了，甚至还通过一些笨办法(抄接口实例)对常用语言API熟悉了很多。\n近期 然后我又尴尬了，因为我能更好的写小项目，但还是很难写出一个大项目。于是我先试着用重构的方法去提高编程能力，这的确有用，特别是结合设计模式来做。但是问题也有，就是我不知道我是不是过度重构了，时间上也有点不能接受。\n于是这才回归到代码阅读。但代码阅读真的太难了，特别是现在的应用代码普遍非常多，我主要学习的又是应用层的各种项目，业务逻辑更多，对我一个菜鸡来说很难直接从头怼到尾。但是我自己是找不到啥思路了，只能继续做代码阅读，于是我翻了各种能搜到的讲代码阅读的文章，还读了一两本代码解析的书，总结了一个阅读流程，没想到竟然还算能用，目前用这个思路读过了Google家的tsunami-scanner，感觉效果不错。\n代码阅读思路 选项目 首先要确定读什么，这个是要看你的目标是什么，我觉得并没有适合所有人的所谓\u0026quot;beginner project\u0026quot;，虽然很多人都会推荐“es“、”flask“，但不要盲从，我觉得要从这几点选择项目：\n 兴趣。不管用啥方法，读代码都挺不容易，不感兴趣硬读，很难坚持下去 目的。要实现一个类似项目？要学习其中某种功能如何实现？要学习下整个项目的模块设计？目的可能是很多的，确定你要的东西在这个项目里有就行，即使这个项目其他方面可能很烂，照样可以读 优美/简单。其他条件都满足的情况下，实现越优美，越简单越好  使用这个项目 自己编译运行这个项目，测试它的各种功能，看看它的文档，如果有高级用法，比如插件，也可以试试做个简单的插件。用的过程中猜一下他可能是咋实现的。\n整理问题 在进入代码海之前，先整理好明确的目标，一般来说有这些常见目标：\n 主要功能有哪些，核心功能是啥 模块怎么划分的，画个图 核心功能怎么实现的，画个时序图 核心模块的状态机图  或者如果你只对某些功能感兴趣，那可能是这样的目标：\n 如何实现的某功能？可否实现另一个功能，如何修改可实现 他用了哪些设计模式？有啥好处？ 这里有什么算法，为啥用这个，性能/效率会有什么影响  整理第三方依赖 接下来是试试水的阶段，我们要大概了解下底层用到了哪些技术，有哪些依赖，把一些不了解的东西拿出来，看看相关文档，写写demo，无需过度研究，只要能看懂，能用就行，不要影响后续理解就行。不过如果这个第三方的技术和你关心的功能有非常强的相关性，那就要先深入学习下。比如你去看Checkstyle代码，那就要了解下Antlr。\n按目录/包略读代码 然后按照包、目录结构去略读一下代码，了解下每个包大概做什么，标记下核心类。如果和你想要的功能有关可以多了解下，看看它依赖什么二方包，那些二方包又是干什么的。\n如果你对某个功能模块非常感兴趣，你已经可以开始仿写了，不过如果这个模块不是比较独立的，那难度会很高。\n调试 目前我们应该大致了解了整个项目，每个包大概干什么，也找到了核心功能相关的包。那么就可以开始调试了，如果你的项目实现比较好，应该是有单元测试的，试着修改下单元测试，看会有什么效果，再去考虑下它是怎么实现的，然后再看看源码。这里最好用ide调试，而不是静态去看。\n仿写/改写 到了这一步，我们基本算是完成了50%。但我认为所有的代码阅读，都要做到仿写/改写，否则就不算完整，眼高手低的问题是很常见的。\n What I can\u0026rsquo;t create, I don\u0026rsquo;t understand.\n END 后续希望自己能做一些实际阅读的过程记录发上来，就先这样吧。\n","date":"2021-07-15","permalink":"/zh-cn/posts/about-code-reading/","series":["代码阅读系列"],"tags":["编程","代码阅读"],"title":"对代码阅读思路的研究"}]